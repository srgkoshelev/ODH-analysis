<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>ODH_analysis.ODH_class API documentation</title>
<meta name="description" content="odh - Oxygen Deficiency Hazard analysis tool â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ODH_analysis.ODH_class</code></h1>
</header>
<section id="section-intro">
<p>odh - Oxygen Deficiency Hazard analysis tool.</p>
<p>Based on Fermilab ES&amp;H Manual chapter 4240 (see
<a href="https://eshq.fnal.gov/manuals/feshm/">https://eshq.fnal.gov/manuals/feshm/</a>)</p>
<p>This package is maintained at <a href="https://github.com/srgkoshelev/ODH_analysis">https://github.com/srgkoshelev/ODH_analysis</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;odh - Oxygen Deficiency Hazard analysis tool.

Based on Fermilab ES&amp;H Manual chapter 4240 (see
https://eshq.fnal.gov/manuals/feshm/)

This package is maintained at https://github.com/srgkoshelev/ODH_analysis&#34;&#34;&#34;

import math
import heat_transfer as ht
from copy import copy

# Setting up the units
ureg = ht.ureg
Q_ = ureg.Quantity

# Loading FESHM 4240 Failure rates
from .FESHM4240_TABLES import TABLE_1, TABLE_2

# Probability of failure on demand for main cases
PFD_ODH = Q_(&#39;2 * 10^-3&#39;)
# TODO Update to value from J. Anderson&#39;s document
TRANSFER_LINE_LEAK_AREA = Q_(&#39;10 mm^2&#39;)
SHOW_SENS = 5e-8/ureg.hr


class Source:
    &#34;&#34;&#34;Source of inert gas&#34;&#34;&#34;
    def __init__(self, name, fluid, volume, N=1):
        &#34;&#34;&#34;Define the possible source of inert gas.

        Parameters
        ----------
        name : str
            Name of the source.
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        volume : ureg.Quantity {length: 3}
            Volume of the fluid stored.
        N : int
            Quantity of the sources if several similar sources exist,
            e.g. gas bottles.
        &#34;&#34;&#34;
        self.name = name
        self.fluid = fluid
        self.leaks = {}
        # Number of sources if multiple exist, e.g. gas cylinders
        # Increases probability of failure by N.
        self.N = N
        # Calculating volume at standard conditions
        temp_state = fluid.copy()
        temp_state.update(&#39;T&#39;, ht.T_NTP, &#39;P&#39;, ht.P_NTP)
        self.volume = volume*fluid.Dmass/temp_state.Dmass
        self.volume.ito(ureg.feet**3)
        # By default assume there is no isolation valve
        # that is used by ODH system
        self.isol_valve = False

    def gas_pipe_failure(self, Pipe, fluid=None, N_welds=1, max_flow=None):
        &#34;&#34;&#34;Add gas pipe failure to the leaks dict.

        Store failure rate, flow rate and expected time duration of the
        event for gas pipe failure. Based on FESHM 4240.
        Failure modes are analyzed by Volume.odh method.

        Parameters
        ----------
        Pipe : heat_transfer.piping.Pipe
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        N_welds : int
            Number of welds on the gas pipe.
        max_flow : ureg.Quantity {mass: 1, time: -1} or {length: 3, time: -1}
            Max mass or volumetric flow through if limited,
            e.g. by compressor output.
        &#34;&#34;&#34;
        # If fluid not defined use fluid of the Source
        fluid = fluid or self.fluid
        # Failure rate coefficients; Piping failure rate is per unit of length,
        # weld is dependent on number of welds, pipe OD and wall thickness
        failure_rate_coeff = {&#39;Piping&#39;: Pipe.L, &#39;Pipe weld&#39;: N_welds *
                              Pipe.OD / Pipe.wall}
        # Piping and weld leaks as per Table 2
        for cause in [&#39;Piping&#39;, &#39;Pipe weld&#39;]:
            for mode in TABLE_2[cause].keys():
                if Pipe.D &gt; 2 or mode != &#39;Large leak&#39;:  # Large leak only for D &gt; 2&#34;
                    name = f&#39;{cause} {mode.lower()}: {Pipe}&#39;
                    TempPipe = copy(Pipe)
                    # Average path for the flow will be half of piping length
                    # for gas piping
                    TempPipe.L = Pipe.L / 2
                    if mode == &#39;Rupture&#39;:
                        failure_rate = failure_rate_coeff[cause] * \
                            TABLE_2[cause][mode]
                        # For rupture calculate flow through available
                        # pipe area
                        area = Pipe.area
                    else:
                        failure_rate = failure_rate_coeff[cause] * \
                            TABLE_2[cause][mode][&#39;Failure rate&#39;]
                        area = TABLE_2[cause][mode][&#39;Area&#39;]
                    if max_flow is not None:
                        q_std_max = ht.piping.to_standard_flow(max_flow, fluid)
                        q_std = min(self._leak_flow(TempPipe, area, fluid),
                                    q_std_max)
                    else:
                        q_std = self._leak_flow(TempPipe, area, fluid)
                    tau = self.volume/q_std
                    self.leaks[name] = (failure_rate.to(1/ureg.hr), q_std,
                                        tau.to(ureg.min))

    def transfer_line_failure(self, Pipe, fluid=None, N=1):
        &#34;&#34;&#34;Add transfer line failure to leaks dict.

        Store failure rate, flow rate and expected time duration of
        the event for transfer line failure. Based on FESHM 4240.
        Failure modes are analyzed by Volume.odh method.

        Parameters
        ----------
        Pipe : heat_transfer.Pipe
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        N : int
            Number of bayonets/soft seals on the transfer line
        &#34;&#34;&#34;
        # TODO Make leak and rupture areas adjustable, add info to docstring
        area_cases = {&#39;Leak&#39;: TRANSFER_LINE_LEAK_AREA,
                      &#39;Rupture&#39;: Pipe.area}
        for mode in TABLE_1[&#39;Fluid line&#39;]:
            name = f&#39;Fluid line {mode.lower()}: {Pipe}&#39;
            failure_rate = N * TABLE_1[&#39;Fluid line&#39;][mode]
            area = area_cases[mode]
            # If fluid not defined use fluid of the Source
            fluid = fluid or self.fluid
            q_std = self._leak_flow(Pipe, area, fluid)
            tau = self.volume/q_std
            self.leaks[name] = (failure_rate.to(1/ureg.hr), q_std,
                                tau.to(ureg.min))

    def dewar_insulation_failure(self, flow_rate, fluid=None):
        &#34;&#34;&#34;Add dewar insulation failure to leaks dict.

        Store failure rate, flow rate and expected time duration of the
        failure event for the dewar insulation failure. Based on FESHM4240.
        Failure modes are analyzed by Volume.odh method.

        Parameters
        ----------
        flow_rate : ureg.Quantity {mass: 1, time: -1} or {length: 3, time: -1}
            Relief flow rate for the case of dewar insulation failure.
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        &#34;&#34;&#34;
        failure_rate = TABLE_1[&#39;Dewar&#39;][&#39;Loss of vacuum&#39;]
        # If fluid not defined use fluid of the Source
        fluid = fluid or self.fluid
        q_std = ht.piping.to_standard_flow(flow_rate, fluid)
        tau = self.volume/q_std
        self.leaks[&#39;Dewar insulation failure&#39;] = (failure_rate.to(1/ureg.hr),
                                                  q_std, tau.to(ureg.min))

    def failure_mode(self, name, failure_rate, flow_rate, fluid=None, N=1):
        &#34;&#34;&#34;Add general failure mode to leaks dict.

        Store failure rate, flow rate and expected time duration of the
        failure event for general failure mode.
        Failure modes are analyzed by Volume.odh method.

        Parameters
        ----------
        name : str
            Name of the failure mode
        failure rate : ureg.Quantity {time: -1}
            Failure rate of the failure mode,
            i.e. how often the failure occurs
        flow_rate : ureg.Quantity {mass: 1, time: -1} or {length: 3, time: -1}
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        N : int
            Quantity of similar failure modes.
        &#34;&#34;&#34;
        # If fluid not defined use fluid of the Source
        fluid = fluid or self.fluid
        q_std = ht.piping.to_standard_flow(flow_rate, fluid)
        tau = self.volume/q_std
        self.leaks[name] = (N*failure_rate.to(1/ureg.hr), q_std,
                            tau.to(ureg.min))

    # def constant_leak(self, name, flow_rate):
    #     tau = self.volume/flow_rate
    #     self.leaks[name] = (None, flow_rate, tau.to(ureg.min))

    def _leak_flow(self, Pipe, Area, fluid):
        &#34;&#34;&#34;Calculate leak flow through a pipe

        Parameters
        ----------
        Pipe : heat_transfer.Pipe
        Area : ureg.Quantity {length: 2}
            Area of the leak.
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.

        Returns
        -------
        ureg.Quantity {length: 3, time: -1}
            Standard volumetric flow. Conditions are defined in
            heat_transfer package (generally NTP).
        &#34;&#34;&#34;
        d = (4*Area/math.pi)**0.5  # diameter for the leak opening
        Entrance = ht.piping.Entrance(d)
        Exit = ht.piping.Exit(d)
        TempPiping = ht.piping.Piping(fluid)
        TempPiping.add(Entrance,
                       Pipe,
                       Exit,
        )
        m_dot = TempPiping.m_dot(ht.P_NTP)
        return ht.piping.to_standard_flow(m_dot, fluid)

    @property
    def sol_PFD(self):
        &#34;&#34;&#34;Calculate probability of failure on demand (PFD) for solenoid valve.


        Returns
        -------
        float
            Probability of failure of a solenoid device
            If the source doesn&#39;t have isolating solenoid valve
            the probability is 1.
        &#34;&#34;&#34;
        return ((not self.isol_valve) or
                TABLE_2[&#39;Valve, solenoid&#39;][&#39;Failure to operate&#39;])

    @staticmethod
    def combine(name, sources):
        &#34;&#34;&#34;Combine several ODH sources sharing volume.

        Can be used for failure modes affecting several sources in parallel.

        Parameters
        ----------
        name : str
            Name of the new combined source.
        sources : list of Source
            Sources connected together.

        Returns
        -------
        Source
            Combined source of inert gas.
        &#34;&#34;&#34;
        fluid = ht.ThermState(sources[0].fluid.name, T=ht.T_NTP, P=ht.P_NTP)
        if all([source.fluid.name == fluid.name for source in sources]):
            total_volume = sum([source.volume for source in sources])
            return Source(name, fluid, total_volume)
        else:
            print(&#39;\nAll volumes should contain the same fluid&#39;)
            return None

    def __str__(self):
        return f&#39;{self.name}, ODH source with &#39; + \
            f&#39;{self.volume.to(ureg.ft**3):.3g~} &#39; + \
            f&#39;of {self.fluid.name} gas.&#39;

    def print_leaks(self):
        &#34;&#34;&#34;Print information on the leaks defined for the source.&#34;&#34;&#34;
        for key in sorted(self.leaks.keys()):
            print(&#39;Failure mode: &#39;+key)
            print(&#39;Failure rate: {:.2~}&#39;.format(self.leaks[key][0]))
            print(&#39;Flow rate: {:.2~}&#39;.format(
                self.leaks[key][1].to(ureg.ft**3/ureg.min)))
            print(&#39;Event duration: {:.2~}&#39;.format(self.leaks[key][2]))
            print()


class Volume:
    &#34;&#34;&#34;Volume/building affected by inert gases.&#34;&#34;&#34;
    def __init__(self, name, volume, Q_fan, N_fans, Test_period):
        &#34;&#34;&#34;Define a volume affected by inert gas release from Source.

        Parameters
        ----------
        name : str
            Name of the volume.
        volume : ureg.Quantity {length: 3}
            Volume of the building or part of the building.
        Q_fan : ureg.Quantity {length: 3, time: -1}
            Volumetric flow of a single ODH fan installed in the volume.
        N_fans : int
            Number of fans installed.
        Test_period : ureg.Quantity {time: 1}
            Test period of the fans.
        &#34;&#34;&#34;
        self.name = name
        self.volume = volume
        self.PFD_ODH = PFD_ODH  # Default value for ODH system failure
        self.lambda_fan = TABLE_2[&#39;Fan&#39;][&#39;Failure to run&#39;]
        self.Q_fan = Q_fan
        self.N_fans = N_fans
        self.Test_period = Test_period

    def odh(self, sources, power_outage=False):
        &#34;&#34;&#34;Calculate ODH fatality rate for given `Source`s.

        For each leak of each source ODH conditions are analyzed and
        fatality rates are calculated. The results are collected in
        failure_modes list.

        Parameters
        ----------
        sources : list
            Sources affecting the volume.
        power_outage : bool
            Shows whether there is a power outage is in effect.
            Default is no outage.
        &#34;&#34;&#34;
        self.phi = 0  # Recalculate fatality rate
        self.failure_modes = []
        # Probability of power failure in the building:
        # PFD_power if no outage, 1 if there is outage
        PFD_power_build = (power_outage or
                           TABLE_1[&#39;Electrical Power Failure&#39;][&#39;Demand rate&#39;])
        # Calculate fan probability of failure
        self._fan_fail(self.Test_period, self.Q_fan, self.N_fans)
        # Calculate fatality rates for each source
        for source in sources:
            for failure_mode_name, leak in source.leaks.items():
                leak_failure_rate = leak[0]
                if leak_failure_rate is not None:  # None for constant leak
                    self._fatality_no_response(source, failure_mode_name, leak,
                                               source.sol_PFD, PFD_power_build)
                    self._fatality_fan_powered(source, failure_mode_name, leak,
                                               PFD_power_build)
                else:
                    # TODO rework constant leak (will throw errors)
                    raise NotImplementedError(&#39;Constant leak analysis is not &#39;
                                              &#39;implemented yet.&#39;)
                    &#34;&#34;&#34;O2_conc = conc_vent(self.volume, q_leak, 0*ureg(&#39;ft^3/min&#39;), tau)
                    F_i = self._fatality_prob(O2_conc)
                    if F_i &gt; 0:
                        print(&#39;Constant leak can be fatal: {source}, \
                        Leak: {leak_rate:.3g~}, tau: {tau:.3g~}&#39;)
                    phi_i = F_i / tau  #  Assessing fatality rate of the cont. leak
                    self.failure_modes.append((phi_i, source, failure_mode_name, O2_conc,
                                               1.0, 1.0,
                                               F_i, power_outage, q_leak, tau, Q_fan))
                    &#34;&#34;&#34;
        # Sort failure modes by fatality rate
        self.failure_modes.sort(key=lambda x: x[0], reverse=True)

    def _fatality_no_response(self, source, failure_mode_name, leak, sol_PFD,
                              PFD_power_build):
        &#34;&#34;&#34;Calculate fatality rate in the volume for ODH protection failure.

        Calculate failure rate of leak occuring and no safety response
        occuring due to power failure and isolation solenoid failure,
        or power on and ODH system failure.
        O2 concentration is limited only by amount of inert gas the source has.
        Fans are not operational.
        Adds calculation results to the failure_modes list.

        Parameters
        ----------
        source : Source
        failure_mode_name : str
            Name of the failure mode
        leak : tuple (ureg.Quantity {time: -1},
                      ureg.Quantity {length: 3, time: -1},
                      ureg.Quantity {time: 1})
            Leak failure rate, volumetric flow rate, and time of the event.
        sol_PFD : float
            Probability of source solenoid failure.
        PFD_power_building : float
            Probability of power failure.
        &#34;&#34;&#34;
        (leak_failure_rate, q_leak, tau) = leak
        P_no_response = float(PFD_power_build)*float(sol_PFD) +\
            (1-PFD_power_build)*self.PFD_ODH
        P_i = leak_failure_rate * P_no_response
        Q_fan = 0 * ureg(&#39;ft^3/min&#39;)
        O2_conc = conc_vent(self.volume, q_leak, Q_fan, tau)
        F_i = self._fatality_prob(O2_conc)
        phi_i = P_i*F_i
        self.phi += phi_i
        self.failure_modes.append((phi_i, source, failure_mode_name, O2_conc,
                                   leak_failure_rate, P_i, F_i,
                                   PFD_power_build == 1, q_leak, tau, Q_fan))

    def _fatality_fan_powered(self, source, failure_mode_name, leak,
                              PFD_power_build):
        &#34;&#34;&#34;Calculate fatality rates for fan failure on demand.

        Calculate fatality rates for the case of ODH system responding and
        fans powered but some of the fans failing on demand.
        See wiki for further explanation.
        Adds calculation results to the failure_modes list.

        Parameters
        ----------
        source : Source
        failure_mode_name : str
            Name of the failure mode
        leak : tuple (ureg.Quantity {time: -1},
                      ureg.Quantity {length: 3, time: -1},
                      ureg.Quantity {time: 1})
            Leak failure rate, volumetric flow rate, and time of the event.
        sol_PFD : float
            Probability of source solenoid failure.
        PFD_power_building : float
            Probability of power failure.
        &#34;&#34;&#34;
        (leak_failure_rate, q_leak, tau) = leak
        for (P_fan, Q_fan) in self.Fan_flowrates:
            # Probability of power on, ODH system working, and m number of fans
            # with flow rate Q_fan on.
            P_response = (1-PFD_power_build) * (1-self.PFD_ODH) * P_fan
            P_i = leak_failure_rate * P_response
            O2_conc = conc_vent(self.volume, q_leak, Q_fan, tau)
            F_i = self._fatality_prob(O2_conc)
            phi_i = P_i*F_i
            self.phi += phi_i
            self.failure_modes.append((phi_i, source, failure_mode_name,
                                       O2_conc, leak_failure_rate, P_i, F_i,
                                       PFD_power_build == 1, q_leak, tau,
                                       Q_fan))

    def _fan_fail(self, Test_period, Q_fan, N_fans):
        &#34;&#34;&#34;Calculate (Probability, flow) pairs for all combinations of fans
        working.

        All fans are expected to have same volume flow.

        Parameters
        ----------
        Test_period : ureg.Quantity {time: 1}
            Test period of the fans.
        Q_fan : ureg.Quantity {length: 3, time: -1}
            Volumetric flow of a single ODH fan installed in the volume.
        N_fans : int
            Number of fans installed.
        &#34;&#34;&#34;
        # TODO add fans with different volumetric rates (see report as well)
        Fail_rate = self.lambda_fan
        Fan_flowrates = []
        for m in range(N_fans+1):
            # Probability of exactly m units starting
            P_m_fan_work = prob_m_of_n(m, N_fans, Test_period, Fail_rate)
            Fan_flowrates.append((P_m_fan_work, Q_fan*m))
        self.Fan_flowrates = Fan_flowrates

    def _fatality_prob(self, O2_conc):
        &#34;&#34;&#34;Calculate fatality probability for given oxygen concentration.

        The equation is fitted from the FESHM 4240 plot.

        Parameters
        ----------
        O2_conc : float
            Oxygen concentration.

        Returns
        -------
        float
            Fatality rate.
        &#34;&#34;&#34;
        if O2_conc &gt;= 0.18:  # Lowest oxygen concentration above 18%
            Fi = 0
        elif O2_conc &lt;= 0.088:  # 8.8% of oxygen is assumed to be 100% fatal
            Fi = 1
        else:
            # Fi formula, reverse engineered using 8.8% and 18% thresholds
            Fi = 10**(6.5-76*O2_conc)
        return Fi

    def odh_class(self):
        &#34;&#34;&#34;Calculate ODH class as defined in FESHM 4240.

        Returns
        -------
        int
            ODH class.
        &#34;&#34;&#34;
        if self.phi &lt; 1e-7/ureg.hr:
            return 0
        elif self.phi &lt; 1e-5/ureg.hr:
            return 1
        elif self.phi &lt; 1e-3/ureg.hr:
            return 2
        else:
            print(&#39;ODH fatality rate is too high. Please, check calculations&#39;)
            return None

    def report(self, brief=True):
        &#34;&#34;&#34;Print a report for failure modes and effects.

        The report is sorted by fatality rate descending.&#34;&#34;&#34;
        title = f&#39;ODH report for {self}&#39;
        padding = len(title) + 10
        print(&#39;#&#39;*padding)
        print(title)
        print(&#39;-&#39;*padding)
        if brief:
            print(&#39;Printing brief ODH report&#39;)
            print(f&#39;Only leaks with Fatality rate &gt; {SHOW_SENS} are shown&#39;)
        for failure_mode in self.failure_modes:
            phi_i = failure_mode[0]
            source = failure_mode[1]
            failure_mode_name = failure_mode[2]
            O2_conc = failure_mode[3]
            leak_failure_rate = failure_mode[4]
            P_i = failure_mode[5]
            F_i = failure_mode[6]
            power_outage = failure_mode[7]
            q_leak = failure_mode[8]
            tau = failure_mode[9]
            N_fan = int(failure_mode[10] / self.Q_fan)
            Q_fan = failure_mode[10]
            if phi_i &gt;= SHOW_SENS or not brief:
                print()
                print(f&#39; Source:               {source.name}&#39;)
                print(f&#39; Failure:              {failure_mode_name}&#39;)
                print(f&#39; Fatality rate:        {phi_i.to(1/ureg.hr):.2~}&#39;)
                print(f&#39; Building is powered:  {not power_outage}&#39;)
                print(f&#39; Oxygen concentration: {O2_conc:.0%}, &#39;
                      f&#39;{O2_conc/0.21:.0%} percent of norm&#39;)
                print(f&#39; Leak failure rate:    {leak_failure_rate:.3g~}&#39;)
                print(&#39; ODH protection PFD:    &#39;
                      f&#39;{(P_i/leak_failure_rate).to(ureg.dimensionless):.2~}&#39;)
                print(f&#39; Total failure rate:   {P_i.to(1/ureg.hr):.2~}&#39;)
                print(f&#39; Leak rate:            {q_leak:.2~}&#39;)
                print(f&#39; Event duration:       {tau:.2~}&#39;)
                print(f&#39; Fans working:         {N_fan:}&#39;)
                print(f&#39; Fan rate:             {Q_fan:.2~}&#39;)
                print(f&#39; Fatality prob:        {F_i:.2g}&#39;)

    def __str__(self):
        return (f&#39;Volume: {self.name}, {self.volume.to(ureg.ft**3):.2~}&#39;)

    # def source_safe(self, source, escape = True):
    #    &#34;&#34;&#34;
    #    Estimate the impact of the Source volume on oxygen concetration. Smaller sources might not be able to drop oxygen concentration to dangerous levels.
    #    &#34;&#34;&#34;
    #    if escape == True:  # if mixed air is allowed to escape within considered volume
    #        O2_conc = 0.21*self.volume/(self.volume+source.volume)
    #    else:  # worst case; inert gas is trapped and expells the air outside the considered volume
    #        O2_conc = 0.21*(1-source.volume/self.volume)
    #    return self._fatality_prob(O2_conc) == 0


def prob_m_of_n(m, n, T, l):
    &#34;&#34;&#34;Calculate the probability of m out of n units working.

    Calculation is done using binomial distribution.

    Parameters
    ----------
    m : int
    Number of units working.
    n : int
    Total number of units.
    T : ureg.Quantity {time: 1}
        Test period
    l : ureg.Quantity {time: -1}
        Failure rate (\\lambda) of a fan

    Returns
    -------
    float
        Probability of m out of n units working.
    &#34;&#34;&#34;
    C_n_m = math.factorial(n)/(math.factorial(n-m)*math.factorial(m))
    PFD_one_unit = l*T
    # Adjustment coefficient: T/(n-m+1) will be average failure reveal time
    # (D. Smith, Reliability..., p. 108)
    F_adj = 1/(n-m+1)
    m_of_n = C_n_m*(PFD_one_unit)**(n-m)*(1-PFD_one_unit)**m*F_adj
    return m_of_n


def conc_vent(V, R, Q, t):
    &#34;&#34;&#34;Calculate the oxygen concentration at the end of the event.

    As defined by FESHM 4240 6.1.A, Cases A, B, and C.

    Parameters
    ----------
    V : ureg.Quantity {length: 3}
        Volume of the confined space.
    R : ureg.Quantity {length: 3, time: -1}
        Volumetric spill rate into confined space.
    Q : ureg.Quantity {length: 3, time: -1}
        Volumetric ventilation rate of fan(s); positive value corresponds
        to blowing air into the confined space, negative - drawing contaminated
        air outside.
    t : ureg.Quantity {time: 1}
        time, beginning of release is at t=0.

    Returns
    -------
    float
        Oxygen concentration.
    &#34;&#34;&#34;
    if Q &gt; 0:
        C = 0.21/(Q+R) * (Q+R*math.e**-(Q+R)/V*t)
    elif abs(Q) &lt;= R:
        C = 0.21*math.e**-(R/V*t)
    elif abs(Q) &gt; R:
        C = 0.21*(1-R/abs(Q)*(1-math.e**-(abs(Q)*t/V)))
    return C


def conc_final(V, R, Q):
    &#34;&#34;&#34;Calculate the final oxygen concentration for continuous flow.

    Equivalent to conc_vent(V, R, Q, float(&#39;inf&#39;)).

    Parameters
    ----------
    V : ureg.Quantity {length: 3}
        Volume of the confined space.
    R : ureg.Quantity {length: 3, time: -1}
        Volumetric spill rate into confined space.
    Q : ureg.Quantity {length: 3, time: -1}
        Volumetric ventilation rate of fan(s); positive value corresponds
        to blowing air into the confined space, negative - drawing contaminated
        air outside.

    Returns
    -------
    float
        Oxygen concentration.
    &#34;&#34;&#34;
    if Q &gt; 0:
        C = 0.21/(Q+R)*Q
    elif abs(Q) &lt;= abs(R):
        C = 0
    elif abs(Q) &gt; abs(R):
        C = 0.21*(1-R/abs(Q))
    return C


def conc_after(V, C_e, Q, t, t_e):
    &#34;&#34;&#34;Calculate the oxygen concentration in the confined volume after
    the release has ended.

    As defined by FESHM 4240 6.1.A, Case D.

    Parameters
    ----------
    V : ureg.Quantity {length: 3}
        Volume of the confined space.
    C_e : float
        Oxygen concentration at the end of the release.
    Q : ureg.Quantity {length: 3, time: -1}
        Volumetric ventilation rate of fan(s); positive value corresponds
        to blowing air into the confined space, negative - drawing contaminated
        air outside.
    t : ureg.Quantity {time: 1}
        time, beginning of release is at t=0.
    t_e : ureg.Quantity {time: 1}
        time when release ended.

    Returns
    -------
    float
        Oxygen concentration.
    &#34;&#34;&#34;
    C = 0.21-(0.21-C_e)*math.e**-(abs(Q)/V*(t-t_e))
    return C


def print_result(*Volumes):
    &#34;&#34;&#34;Print the results of the ODH analysis for a volume.

    If several volumes given (in case of interlapping volumes) the worst case
    will be printed.
    &#34;&#34;&#34;
    max_phi = -1/ureg.hr
    for volume in Volumes:
        if volume.phi &gt; max_phi:
            max_volume = volume
    line_1 = &#39;# Fatality rate for {} is {:.1e}  # &#39;.format(max_volume, volume.phi)
    pad = len(line_1)
    line_2 = &#39;# Recommended ODH class {}&#39;.format(max_volume.odh_class()).ljust(pad-1)+&#39;#&#39;
    print(&#39;#&#39;*pad)
    print(line_1)
    print(line_2)
    print(&#39;#&#39;*pad)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ODH_analysis.ODH_class.conc_after"><code class="name flex">
<span>def <span class="ident">conc_after</span></span>(<span>V, C_e, Q, t, t_e)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the oxygen concentration in the confined volume after
the release has ended.</p>
<p>As defined by FESHM 4240 6.1.A, Case D.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>ureg.Quantity {length: 3}</code></dt>
<dd>Volume of the confined space.</dd>
<dt><strong><code>C_e</code></strong> :&ensp;<code>float</code></dt>
<dd>Oxygen concentration at the end of the release.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>ureg.Quantity {length: 3, time: -1}</code></dt>
<dd>Volumetric ventilation rate of fan(s); positive value corresponds
to blowing air into the confined space, negative - drawing contaminated
air outside.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>ureg.Quantity {time: 1}</code></dt>
<dd>time, beginning of release is at t=0.</dd>
<dt><strong><code>t_e</code></strong> :&ensp;<code>ureg.Quantity {time: 1}</code></dt>
<dd>time when release ended.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Oxygen concentration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conc_after(V, C_e, Q, t, t_e):
    &#34;&#34;&#34;Calculate the oxygen concentration in the confined volume after
    the release has ended.

    As defined by FESHM 4240 6.1.A, Case D.

    Parameters
    ----------
    V : ureg.Quantity {length: 3}
        Volume of the confined space.
    C_e : float
        Oxygen concentration at the end of the release.
    Q : ureg.Quantity {length: 3, time: -1}
        Volumetric ventilation rate of fan(s); positive value corresponds
        to blowing air into the confined space, negative - drawing contaminated
        air outside.
    t : ureg.Quantity {time: 1}
        time, beginning of release is at t=0.
    t_e : ureg.Quantity {time: 1}
        time when release ended.

    Returns
    -------
    float
        Oxygen concentration.
    &#34;&#34;&#34;
    C = 0.21-(0.21-C_e)*math.e**-(abs(Q)/V*(t-t_e))
    return C</code></pre>
</details>
</dd>
<dt id="ODH_analysis.ODH_class.conc_final"><code class="name flex">
<span>def <span class="ident">conc_final</span></span>(<span>V, R, Q)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the final oxygen concentration for continuous flow.</p>
<p>Equivalent to conc_vent(V, R, Q, float('inf')).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>ureg.Quantity {length: 3}</code></dt>
<dd>Volume of the confined space.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>ureg.Quantity {length: 3, time: -1}</code></dt>
<dd>Volumetric spill rate into confined space.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>ureg.Quantity {length: 3, time: -1}</code></dt>
<dd>Volumetric ventilation rate of fan(s); positive value corresponds
to blowing air into the confined space, negative - drawing contaminated
air outside.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Oxygen concentration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conc_final(V, R, Q):
    &#34;&#34;&#34;Calculate the final oxygen concentration for continuous flow.

    Equivalent to conc_vent(V, R, Q, float(&#39;inf&#39;)).

    Parameters
    ----------
    V : ureg.Quantity {length: 3}
        Volume of the confined space.
    R : ureg.Quantity {length: 3, time: -1}
        Volumetric spill rate into confined space.
    Q : ureg.Quantity {length: 3, time: -1}
        Volumetric ventilation rate of fan(s); positive value corresponds
        to blowing air into the confined space, negative - drawing contaminated
        air outside.

    Returns
    -------
    float
        Oxygen concentration.
    &#34;&#34;&#34;
    if Q &gt; 0:
        C = 0.21/(Q+R)*Q
    elif abs(Q) &lt;= abs(R):
        C = 0
    elif abs(Q) &gt; abs(R):
        C = 0.21*(1-R/abs(Q))
    return C</code></pre>
</details>
</dd>
<dt id="ODH_analysis.ODH_class.conc_vent"><code class="name flex">
<span>def <span class="ident">conc_vent</span></span>(<span>V, R, Q, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the oxygen concentration at the end of the event.</p>
<p>As defined by FESHM 4240 6.1.A, Cases A, B, and C.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>ureg.Quantity {length: 3}</code></dt>
<dd>Volume of the confined space.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>ureg.Quantity {length: 3, time: -1}</code></dt>
<dd>Volumetric spill rate into confined space.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>ureg.Quantity {length: 3, time: -1}</code></dt>
<dd>Volumetric ventilation rate of fan(s); positive value corresponds
to blowing air into the confined space, negative - drawing contaminated
air outside.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>ureg.Quantity {time: 1}</code></dt>
<dd>time, beginning of release is at t=0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Oxygen concentration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conc_vent(V, R, Q, t):
    &#34;&#34;&#34;Calculate the oxygen concentration at the end of the event.

    As defined by FESHM 4240 6.1.A, Cases A, B, and C.

    Parameters
    ----------
    V : ureg.Quantity {length: 3}
        Volume of the confined space.
    R : ureg.Quantity {length: 3, time: -1}
        Volumetric spill rate into confined space.
    Q : ureg.Quantity {length: 3, time: -1}
        Volumetric ventilation rate of fan(s); positive value corresponds
        to blowing air into the confined space, negative - drawing contaminated
        air outside.
    t : ureg.Quantity {time: 1}
        time, beginning of release is at t=0.

    Returns
    -------
    float
        Oxygen concentration.
    &#34;&#34;&#34;
    if Q &gt; 0:
        C = 0.21/(Q+R) * (Q+R*math.e**-(Q+R)/V*t)
    elif abs(Q) &lt;= R:
        C = 0.21*math.e**-(R/V*t)
    elif abs(Q) &gt; R:
        C = 0.21*(1-R/abs(Q)*(1-math.e**-(abs(Q)*t/V)))
    return C</code></pre>
</details>
</dd>
<dt id="ODH_analysis.ODH_class.print_result"><code class="name flex">
<span>def <span class="ident">print_result</span></span>(<span>*Volumes)</span>
</code></dt>
<dd>
<div class="desc"><p>Print the results of the ODH analysis for a volume.</p>
<p>If several volumes given (in case of interlapping volumes) the worst case
will be printed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_result(*Volumes):
    &#34;&#34;&#34;Print the results of the ODH analysis for a volume.

    If several volumes given (in case of interlapping volumes) the worst case
    will be printed.
    &#34;&#34;&#34;
    max_phi = -1/ureg.hr
    for volume in Volumes:
        if volume.phi &gt; max_phi:
            max_volume = volume
    line_1 = &#39;# Fatality rate for {} is {:.1e}  # &#39;.format(max_volume, volume.phi)
    pad = len(line_1)
    line_2 = &#39;# Recommended ODH class {}&#39;.format(max_volume.odh_class()).ljust(pad-1)+&#39;#&#39;
    print(&#39;#&#39;*pad)
    print(line_1)
    print(line_2)
    print(&#39;#&#39;*pad)</code></pre>
</details>
</dd>
<dt id="ODH_analysis.ODH_class.prob_m_of_n"><code class="name flex">
<span>def <span class="ident">prob_m_of_n</span></span>(<span>m, n, T, l)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the probability of m out of n units working.</p>
<p>Calculation is done using binomial distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>Number of units working.</dt>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>Total number of units.</dt>
<dt><strong><code>T</code></strong> :&ensp;<code>ureg.Quantity {time: 1}</code></dt>
<dd>Test period</dd>
<dt><strong><code>l</code></strong> :&ensp;<code>ureg.Quantity {time: -1}</code></dt>
<dd>Failure rate (\lambda) of a fan</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Probability of m out of n units working.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prob_m_of_n(m, n, T, l):
    &#34;&#34;&#34;Calculate the probability of m out of n units working.

    Calculation is done using binomial distribution.

    Parameters
    ----------
    m : int
    Number of units working.
    n : int
    Total number of units.
    T : ureg.Quantity {time: 1}
        Test period
    l : ureg.Quantity {time: -1}
        Failure rate (\\lambda) of a fan

    Returns
    -------
    float
        Probability of m out of n units working.
    &#34;&#34;&#34;
    C_n_m = math.factorial(n)/(math.factorial(n-m)*math.factorial(m))
    PFD_one_unit = l*T
    # Adjustment coefficient: T/(n-m+1) will be average failure reveal time
    # (D. Smith, Reliability..., p. 108)
    F_adj = 1/(n-m+1)
    m_of_n = C_n_m*(PFD_one_unit)**(n-m)*(1-PFD_one_unit)**m*F_adj
    return m_of_n</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ODH_analysis.ODH_class.Source"><code class="flex name class">
<span>class <span class="ident">Source</span></span>
<span>(</span><span>name, fluid, volume, N=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Source of inert gas</p>
<p>Define the possible source of inert gas.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the source.</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>ureg.Quantity {length: 3}</code></dt>
<dd>Volume of the fluid stored.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Quantity of the sources if several similar sources exist,
e.g. gas bottles.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Source:
    &#34;&#34;&#34;Source of inert gas&#34;&#34;&#34;
    def __init__(self, name, fluid, volume, N=1):
        &#34;&#34;&#34;Define the possible source of inert gas.

        Parameters
        ----------
        name : str
            Name of the source.
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        volume : ureg.Quantity {length: 3}
            Volume of the fluid stored.
        N : int
            Quantity of the sources if several similar sources exist,
            e.g. gas bottles.
        &#34;&#34;&#34;
        self.name = name
        self.fluid = fluid
        self.leaks = {}
        # Number of sources if multiple exist, e.g. gas cylinders
        # Increases probability of failure by N.
        self.N = N
        # Calculating volume at standard conditions
        temp_state = fluid.copy()
        temp_state.update(&#39;T&#39;, ht.T_NTP, &#39;P&#39;, ht.P_NTP)
        self.volume = volume*fluid.Dmass/temp_state.Dmass
        self.volume.ito(ureg.feet**3)
        # By default assume there is no isolation valve
        # that is used by ODH system
        self.isol_valve = False

    def gas_pipe_failure(self, Pipe, fluid=None, N_welds=1, max_flow=None):
        &#34;&#34;&#34;Add gas pipe failure to the leaks dict.

        Store failure rate, flow rate and expected time duration of the
        event for gas pipe failure. Based on FESHM 4240.
        Failure modes are analyzed by Volume.odh method.

        Parameters
        ----------
        Pipe : heat_transfer.piping.Pipe
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        N_welds : int
            Number of welds on the gas pipe.
        max_flow : ureg.Quantity {mass: 1, time: -1} or {length: 3, time: -1}
            Max mass or volumetric flow through if limited,
            e.g. by compressor output.
        &#34;&#34;&#34;
        # If fluid not defined use fluid of the Source
        fluid = fluid or self.fluid
        # Failure rate coefficients; Piping failure rate is per unit of length,
        # weld is dependent on number of welds, pipe OD and wall thickness
        failure_rate_coeff = {&#39;Piping&#39;: Pipe.L, &#39;Pipe weld&#39;: N_welds *
                              Pipe.OD / Pipe.wall}
        # Piping and weld leaks as per Table 2
        for cause in [&#39;Piping&#39;, &#39;Pipe weld&#39;]:
            for mode in TABLE_2[cause].keys():
                if Pipe.D &gt; 2 or mode != &#39;Large leak&#39;:  # Large leak only for D &gt; 2&#34;
                    name = f&#39;{cause} {mode.lower()}: {Pipe}&#39;
                    TempPipe = copy(Pipe)
                    # Average path for the flow will be half of piping length
                    # for gas piping
                    TempPipe.L = Pipe.L / 2
                    if mode == &#39;Rupture&#39;:
                        failure_rate = failure_rate_coeff[cause] * \
                            TABLE_2[cause][mode]
                        # For rupture calculate flow through available
                        # pipe area
                        area = Pipe.area
                    else:
                        failure_rate = failure_rate_coeff[cause] * \
                            TABLE_2[cause][mode][&#39;Failure rate&#39;]
                        area = TABLE_2[cause][mode][&#39;Area&#39;]
                    if max_flow is not None:
                        q_std_max = ht.piping.to_standard_flow(max_flow, fluid)
                        q_std = min(self._leak_flow(TempPipe, area, fluid),
                                    q_std_max)
                    else:
                        q_std = self._leak_flow(TempPipe, area, fluid)
                    tau = self.volume/q_std
                    self.leaks[name] = (failure_rate.to(1/ureg.hr), q_std,
                                        tau.to(ureg.min))

    def transfer_line_failure(self, Pipe, fluid=None, N=1):
        &#34;&#34;&#34;Add transfer line failure to leaks dict.

        Store failure rate, flow rate and expected time duration of
        the event for transfer line failure. Based on FESHM 4240.
        Failure modes are analyzed by Volume.odh method.

        Parameters
        ----------
        Pipe : heat_transfer.Pipe
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        N : int
            Number of bayonets/soft seals on the transfer line
        &#34;&#34;&#34;
        # TODO Make leak and rupture areas adjustable, add info to docstring
        area_cases = {&#39;Leak&#39;: TRANSFER_LINE_LEAK_AREA,
                      &#39;Rupture&#39;: Pipe.area}
        for mode in TABLE_1[&#39;Fluid line&#39;]:
            name = f&#39;Fluid line {mode.lower()}: {Pipe}&#39;
            failure_rate = N * TABLE_1[&#39;Fluid line&#39;][mode]
            area = area_cases[mode]
            # If fluid not defined use fluid of the Source
            fluid = fluid or self.fluid
            q_std = self._leak_flow(Pipe, area, fluid)
            tau = self.volume/q_std
            self.leaks[name] = (failure_rate.to(1/ureg.hr), q_std,
                                tau.to(ureg.min))

    def dewar_insulation_failure(self, flow_rate, fluid=None):
        &#34;&#34;&#34;Add dewar insulation failure to leaks dict.

        Store failure rate, flow rate and expected time duration of the
        failure event for the dewar insulation failure. Based on FESHM4240.
        Failure modes are analyzed by Volume.odh method.

        Parameters
        ----------
        flow_rate : ureg.Quantity {mass: 1, time: -1} or {length: 3, time: -1}
            Relief flow rate for the case of dewar insulation failure.
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        &#34;&#34;&#34;
        failure_rate = TABLE_1[&#39;Dewar&#39;][&#39;Loss of vacuum&#39;]
        # If fluid not defined use fluid of the Source
        fluid = fluid or self.fluid
        q_std = ht.piping.to_standard_flow(flow_rate, fluid)
        tau = self.volume/q_std
        self.leaks[&#39;Dewar insulation failure&#39;] = (failure_rate.to(1/ureg.hr),
                                                  q_std, tau.to(ureg.min))

    def failure_mode(self, name, failure_rate, flow_rate, fluid=None, N=1):
        &#34;&#34;&#34;Add general failure mode to leaks dict.

        Store failure rate, flow rate and expected time duration of the
        failure event for general failure mode.
        Failure modes are analyzed by Volume.odh method.

        Parameters
        ----------
        name : str
            Name of the failure mode
        failure rate : ureg.Quantity {time: -1}
            Failure rate of the failure mode,
            i.e. how often the failure occurs
        flow_rate : ureg.Quantity {mass: 1, time: -1} or {length: 3, time: -1}
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        N : int
            Quantity of similar failure modes.
        &#34;&#34;&#34;
        # If fluid not defined use fluid of the Source
        fluid = fluid or self.fluid
        q_std = ht.piping.to_standard_flow(flow_rate, fluid)
        tau = self.volume/q_std
        self.leaks[name] = (N*failure_rate.to(1/ureg.hr), q_std,
                            tau.to(ureg.min))

    # def constant_leak(self, name, flow_rate):
    #     tau = self.volume/flow_rate
    #     self.leaks[name] = (None, flow_rate, tau.to(ureg.min))

    def _leak_flow(self, Pipe, Area, fluid):
        &#34;&#34;&#34;Calculate leak flow through a pipe

        Parameters
        ----------
        Pipe : heat_transfer.Pipe
        Area : ureg.Quantity {length: 2}
            Area of the leak.
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.

        Returns
        -------
        ureg.Quantity {length: 3, time: -1}
            Standard volumetric flow. Conditions are defined in
            heat_transfer package (generally NTP).
        &#34;&#34;&#34;
        d = (4*Area/math.pi)**0.5  # diameter for the leak opening
        Entrance = ht.piping.Entrance(d)
        Exit = ht.piping.Exit(d)
        TempPiping = ht.piping.Piping(fluid)
        TempPiping.add(Entrance,
                       Pipe,
                       Exit,
        )
        m_dot = TempPiping.m_dot(ht.P_NTP)
        return ht.piping.to_standard_flow(m_dot, fluid)

    @property
    def sol_PFD(self):
        &#34;&#34;&#34;Calculate probability of failure on demand (PFD) for solenoid valve.


        Returns
        -------
        float
            Probability of failure of a solenoid device
            If the source doesn&#39;t have isolating solenoid valve
            the probability is 1.
        &#34;&#34;&#34;
        return ((not self.isol_valve) or
                TABLE_2[&#39;Valve, solenoid&#39;][&#39;Failure to operate&#39;])

    @staticmethod
    def combine(name, sources):
        &#34;&#34;&#34;Combine several ODH sources sharing volume.

        Can be used for failure modes affecting several sources in parallel.

        Parameters
        ----------
        name : str
            Name of the new combined source.
        sources : list of Source
            Sources connected together.

        Returns
        -------
        Source
            Combined source of inert gas.
        &#34;&#34;&#34;
        fluid = ht.ThermState(sources[0].fluid.name, T=ht.T_NTP, P=ht.P_NTP)
        if all([source.fluid.name == fluid.name for source in sources]):
            total_volume = sum([source.volume for source in sources])
            return Source(name, fluid, total_volume)
        else:
            print(&#39;\nAll volumes should contain the same fluid&#39;)
            return None

    def __str__(self):
        return f&#39;{self.name}, ODH source with &#39; + \
            f&#39;{self.volume.to(ureg.ft**3):.3g~} &#39; + \
            f&#39;of {self.fluid.name} gas.&#39;

    def print_leaks(self):
        &#34;&#34;&#34;Print information on the leaks defined for the source.&#34;&#34;&#34;
        for key in sorted(self.leaks.keys()):
            print(&#39;Failure mode: &#39;+key)
            print(&#39;Failure rate: {:.2~}&#39;.format(self.leaks[key][0]))
            print(&#39;Flow rate: {:.2~}&#39;.format(
                self.leaks[key][1].to(ureg.ft**3/ureg.min)))
            print(&#39;Event duration: {:.2~}&#39;.format(self.leaks[key][2]))
            print()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="ODH_analysis.ODH_class.Source.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>name, sources)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine several ODH sources sharing volume.</p>
<p>Can be used for failure modes affecting several sources in parallel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the new combined source.</dd>
<dt><strong><code>sources</code></strong> :&ensp;<code>list</code> of <code><a title="ODH_analysis.ODH_class.Source" href="#ODH_analysis.ODH_class.Source">Source</a></code></dt>
<dd>Sources connected together.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ODH_analysis.ODH_class.Source" href="#ODH_analysis.ODH_class.Source">Source</a></code></dt>
<dd>Combined source of inert gas.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def combine(name, sources):
    &#34;&#34;&#34;Combine several ODH sources sharing volume.

    Can be used for failure modes affecting several sources in parallel.

    Parameters
    ----------
    name : str
        Name of the new combined source.
    sources : list of Source
        Sources connected together.

    Returns
    -------
    Source
        Combined source of inert gas.
    &#34;&#34;&#34;
    fluid = ht.ThermState(sources[0].fluid.name, T=ht.T_NTP, P=ht.P_NTP)
    if all([source.fluid.name == fluid.name for source in sources]):
        total_volume = sum([source.volume for source in sources])
        return Source(name, fluid, total_volume)
    else:
        print(&#39;\nAll volumes should contain the same fluid&#39;)
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ODH_analysis.ODH_class.Source.sol_PFD"><code class="name">var <span class="ident">sol_PFD</span></code></dt>
<dd>
<div class="desc"><p>Calculate probability of failure on demand (PFD) for solenoid valve.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Probability of failure of a solenoid device
If the source doesn't have isolating solenoid valve
the probability is 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sol_PFD(self):
    &#34;&#34;&#34;Calculate probability of failure on demand (PFD) for solenoid valve.


    Returns
    -------
    float
        Probability of failure of a solenoid device
        If the source doesn&#39;t have isolating solenoid valve
        the probability is 1.
    &#34;&#34;&#34;
    return ((not self.isol_valve) or
            TABLE_2[&#39;Valve, solenoid&#39;][&#39;Failure to operate&#39;])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ODH_analysis.ODH_class.Source.dewar_insulation_failure"><code class="name flex">
<span>def <span class="ident">dewar_insulation_failure</span></span>(<span>self, flow_rate, fluid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add dewar insulation failure to leaks dict.</p>
<p>Store failure rate, flow rate and expected time duration of the
failure event for the dewar insulation failure. Based on FESHM4240.
Failure modes are analyzed by Volume.odh method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flow_rate</code></strong> :&ensp;<code>ureg.Quantity {mass: 1, time: -1}</code> or <code>{length: 3, time: -1}</code></dt>
<dd>Relief flow rate for the case of dewar insulation failure.</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dewar_insulation_failure(self, flow_rate, fluid=None):
    &#34;&#34;&#34;Add dewar insulation failure to leaks dict.

    Store failure rate, flow rate and expected time duration of the
    failure event for the dewar insulation failure. Based on FESHM4240.
    Failure modes are analyzed by Volume.odh method.

    Parameters
    ----------
    flow_rate : ureg.Quantity {mass: 1, time: -1} or {length: 3, time: -1}
        Relief flow rate for the case of dewar insulation failure.
    fluid : heat_transfer.ThermState
        Thermodynamic state of the fluid stored in the source.
    &#34;&#34;&#34;
    failure_rate = TABLE_1[&#39;Dewar&#39;][&#39;Loss of vacuum&#39;]
    # If fluid not defined use fluid of the Source
    fluid = fluid or self.fluid
    q_std = ht.piping.to_standard_flow(flow_rate, fluid)
    tau = self.volume/q_std
    self.leaks[&#39;Dewar insulation failure&#39;] = (failure_rate.to(1/ureg.hr),
                                              q_std, tau.to(ureg.min))</code></pre>
</details>
</dd>
<dt id="ODH_analysis.ODH_class.Source.failure_mode"><code class="name flex">
<span>def <span class="ident">failure_mode</span></span>(<span>self, name, failure_rate, flow_rate, fluid=None, N=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Add general failure mode to leaks dict.</p>
<p>Store failure rate, flow rate and expected time duration of the
failure event for general failure mode.
Failure modes are analyzed by Volume.odh method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the failure mode</dd>
<dt -1 time:>failure rate : ureg.Quantity</dt>
<dt>Failure rate of the failure mode,</dt>
<dt>i.e. how often the failure occurs</dt>
<dt><strong><code>flow_rate</code></strong> :&ensp;<code>ureg.Quantity {mass: 1, time: -1}</code> or <code>{length: 3, time: -1}</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Quantity of similar failure modes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def failure_mode(self, name, failure_rate, flow_rate, fluid=None, N=1):
    &#34;&#34;&#34;Add general failure mode to leaks dict.

    Store failure rate, flow rate and expected time duration of the
    failure event for general failure mode.
    Failure modes are analyzed by Volume.odh method.

    Parameters
    ----------
    name : str
        Name of the failure mode
    failure rate : ureg.Quantity {time: -1}
        Failure rate of the failure mode,
        i.e. how often the failure occurs
    flow_rate : ureg.Quantity {mass: 1, time: -1} or {length: 3, time: -1}
    fluid : heat_transfer.ThermState
        Thermodynamic state of the fluid stored in the source.
    N : int
        Quantity of similar failure modes.
    &#34;&#34;&#34;
    # If fluid not defined use fluid of the Source
    fluid = fluid or self.fluid
    q_std = ht.piping.to_standard_flow(flow_rate, fluid)
    tau = self.volume/q_std
    self.leaks[name] = (N*failure_rate.to(1/ureg.hr), q_std,
                        tau.to(ureg.min))</code></pre>
</details>
</dd>
<dt id="ODH_analysis.ODH_class.Source.gas_pipe_failure"><code class="name flex">
<span>def <span class="ident">gas_pipe_failure</span></span>(<span>self, Pipe, fluid=None, N_welds=1, max_flow=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add gas pipe failure to the leaks dict.</p>
<p>Store failure rate, flow rate and expected time duration of the
event for gas pipe failure. Based on FESHM 4240.
Failure modes are analyzed by Volume.odh method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Pipe</code></strong> :&ensp;<code>heat_transfer.piping.Pipe</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
<dt><strong><code>N_welds</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of welds on the gas pipe.</dd>
<dt><strong><code>max_flow</code></strong> :&ensp;<code>ureg.Quantity {mass: 1, time: -1}</code> or <code>{length: 3, time: -1}</code></dt>
<dd>Max mass or volumetric flow through if limited,
e.g. by compressor output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gas_pipe_failure(self, Pipe, fluid=None, N_welds=1, max_flow=None):
    &#34;&#34;&#34;Add gas pipe failure to the leaks dict.

    Store failure rate, flow rate and expected time duration of the
    event for gas pipe failure. Based on FESHM 4240.
    Failure modes are analyzed by Volume.odh method.

    Parameters
    ----------
    Pipe : heat_transfer.piping.Pipe
    fluid : heat_transfer.ThermState
        Thermodynamic state of the fluid stored in the source.
    N_welds : int
        Number of welds on the gas pipe.
    max_flow : ureg.Quantity {mass: 1, time: -1} or {length: 3, time: -1}
        Max mass or volumetric flow through if limited,
        e.g. by compressor output.
    &#34;&#34;&#34;
    # If fluid not defined use fluid of the Source
    fluid = fluid or self.fluid
    # Failure rate coefficients; Piping failure rate is per unit of length,
    # weld is dependent on number of welds, pipe OD and wall thickness
    failure_rate_coeff = {&#39;Piping&#39;: Pipe.L, &#39;Pipe weld&#39;: N_welds *
                          Pipe.OD / Pipe.wall}
    # Piping and weld leaks as per Table 2
    for cause in [&#39;Piping&#39;, &#39;Pipe weld&#39;]:
        for mode in TABLE_2[cause].keys():
            if Pipe.D &gt; 2 or mode != &#39;Large leak&#39;:  # Large leak only for D &gt; 2&#34;
                name = f&#39;{cause} {mode.lower()}: {Pipe}&#39;
                TempPipe = copy(Pipe)
                # Average path for the flow will be half of piping length
                # for gas piping
                TempPipe.L = Pipe.L / 2
                if mode == &#39;Rupture&#39;:
                    failure_rate = failure_rate_coeff[cause] * \
                        TABLE_2[cause][mode]
                    # For rupture calculate flow through available
                    # pipe area
                    area = Pipe.area
                else:
                    failure_rate = failure_rate_coeff[cause] * \
                        TABLE_2[cause][mode][&#39;Failure rate&#39;]
                    area = TABLE_2[cause][mode][&#39;Area&#39;]
                if max_flow is not None:
                    q_std_max = ht.piping.to_standard_flow(max_flow, fluid)
                    q_std = min(self._leak_flow(TempPipe, area, fluid),
                                q_std_max)
                else:
                    q_std = self._leak_flow(TempPipe, area, fluid)
                tau = self.volume/q_std
                self.leaks[name] = (failure_rate.to(1/ureg.hr), q_std,
                                    tau.to(ureg.min))</code></pre>
</details>
</dd>
<dt id="ODH_analysis.ODH_class.Source.print_leaks"><code class="name flex">
<span>def <span class="ident">print_leaks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print information on the leaks defined for the source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_leaks(self):
    &#34;&#34;&#34;Print information on the leaks defined for the source.&#34;&#34;&#34;
    for key in sorted(self.leaks.keys()):
        print(&#39;Failure mode: &#39;+key)
        print(&#39;Failure rate: {:.2~}&#39;.format(self.leaks[key][0]))
        print(&#39;Flow rate: {:.2~}&#39;.format(
            self.leaks[key][1].to(ureg.ft**3/ureg.min)))
        print(&#39;Event duration: {:.2~}&#39;.format(self.leaks[key][2]))
        print()</code></pre>
</details>
</dd>
<dt id="ODH_analysis.ODH_class.Source.transfer_line_failure"><code class="name flex">
<span>def <span class="ident">transfer_line_failure</span></span>(<span>self, Pipe, fluid=None, N=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Add transfer line failure to leaks dict.</p>
<p>Store failure rate, flow rate and expected time duration of
the event for transfer line failure. Based on FESHM 4240.
Failure modes are analyzed by Volume.odh method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Pipe</code></strong> :&ensp;<code>heat_transfer.Pipe</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of bayonets/soft seals on the transfer line</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_line_failure(self, Pipe, fluid=None, N=1):
    &#34;&#34;&#34;Add transfer line failure to leaks dict.

    Store failure rate, flow rate and expected time duration of
    the event for transfer line failure. Based on FESHM 4240.
    Failure modes are analyzed by Volume.odh method.

    Parameters
    ----------
    Pipe : heat_transfer.Pipe
    fluid : heat_transfer.ThermState
        Thermodynamic state of the fluid stored in the source.
    N : int
        Number of bayonets/soft seals on the transfer line
    &#34;&#34;&#34;
    # TODO Make leak and rupture areas adjustable, add info to docstring
    area_cases = {&#39;Leak&#39;: TRANSFER_LINE_LEAK_AREA,
                  &#39;Rupture&#39;: Pipe.area}
    for mode in TABLE_1[&#39;Fluid line&#39;]:
        name = f&#39;Fluid line {mode.lower()}: {Pipe}&#39;
        failure_rate = N * TABLE_1[&#39;Fluid line&#39;][mode]
        area = area_cases[mode]
        # If fluid not defined use fluid of the Source
        fluid = fluid or self.fluid
        q_std = self._leak_flow(Pipe, area, fluid)
        tau = self.volume/q_std
        self.leaks[name] = (failure_rate.to(1/ureg.hr), q_std,
                            tau.to(ureg.min))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ODH_analysis.ODH_class.Volume"><code class="flex name class">
<span>class <span class="ident">Volume</span></span>
<span>(</span><span>name, volume, Q_fan, N_fans, Test_period)</span>
</code></dt>
<dd>
<div class="desc"><p>Volume/building affected by inert gases.</p>
<p>Define a volume affected by inert gas release from Source.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the volume.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>ureg.Quantity {length: 3}</code></dt>
<dd>Volume of the building or part of the building.</dd>
<dt><strong><code>Q_fan</code></strong> :&ensp;<code>ureg.Quantity {length: 3, time: -1}</code></dt>
<dd>Volumetric flow of a single ODH fan installed in the volume.</dd>
<dt><strong><code>N_fans</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of fans installed.</dd>
<dt><strong><code>Test_period</code></strong> :&ensp;<code>ureg.Quantity {time: 1}</code></dt>
<dd>Test period of the fans.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Volume:
    &#34;&#34;&#34;Volume/building affected by inert gases.&#34;&#34;&#34;
    def __init__(self, name, volume, Q_fan, N_fans, Test_period):
        &#34;&#34;&#34;Define a volume affected by inert gas release from Source.

        Parameters
        ----------
        name : str
            Name of the volume.
        volume : ureg.Quantity {length: 3}
            Volume of the building or part of the building.
        Q_fan : ureg.Quantity {length: 3, time: -1}
            Volumetric flow of a single ODH fan installed in the volume.
        N_fans : int
            Number of fans installed.
        Test_period : ureg.Quantity {time: 1}
            Test period of the fans.
        &#34;&#34;&#34;
        self.name = name
        self.volume = volume
        self.PFD_ODH = PFD_ODH  # Default value for ODH system failure
        self.lambda_fan = TABLE_2[&#39;Fan&#39;][&#39;Failure to run&#39;]
        self.Q_fan = Q_fan
        self.N_fans = N_fans
        self.Test_period = Test_period

    def odh(self, sources, power_outage=False):
        &#34;&#34;&#34;Calculate ODH fatality rate for given `Source`s.

        For each leak of each source ODH conditions are analyzed and
        fatality rates are calculated. The results are collected in
        failure_modes list.

        Parameters
        ----------
        sources : list
            Sources affecting the volume.
        power_outage : bool
            Shows whether there is a power outage is in effect.
            Default is no outage.
        &#34;&#34;&#34;
        self.phi = 0  # Recalculate fatality rate
        self.failure_modes = []
        # Probability of power failure in the building:
        # PFD_power if no outage, 1 if there is outage
        PFD_power_build = (power_outage or
                           TABLE_1[&#39;Electrical Power Failure&#39;][&#39;Demand rate&#39;])
        # Calculate fan probability of failure
        self._fan_fail(self.Test_period, self.Q_fan, self.N_fans)
        # Calculate fatality rates for each source
        for source in sources:
            for failure_mode_name, leak in source.leaks.items():
                leak_failure_rate = leak[0]
                if leak_failure_rate is not None:  # None for constant leak
                    self._fatality_no_response(source, failure_mode_name, leak,
                                               source.sol_PFD, PFD_power_build)
                    self._fatality_fan_powered(source, failure_mode_name, leak,
                                               PFD_power_build)
                else:
                    # TODO rework constant leak (will throw errors)
                    raise NotImplementedError(&#39;Constant leak analysis is not &#39;
                                              &#39;implemented yet.&#39;)
                    &#34;&#34;&#34;O2_conc = conc_vent(self.volume, q_leak, 0*ureg(&#39;ft^3/min&#39;), tau)
                    F_i = self._fatality_prob(O2_conc)
                    if F_i &gt; 0:
                        print(&#39;Constant leak can be fatal: {source}, \
                        Leak: {leak_rate:.3g~}, tau: {tau:.3g~}&#39;)
                    phi_i = F_i / tau  #  Assessing fatality rate of the cont. leak
                    self.failure_modes.append((phi_i, source, failure_mode_name, O2_conc,
                                               1.0, 1.0,
                                               F_i, power_outage, q_leak, tau, Q_fan))
                    &#34;&#34;&#34;
        # Sort failure modes by fatality rate
        self.failure_modes.sort(key=lambda x: x[0], reverse=True)

    def _fatality_no_response(self, source, failure_mode_name, leak, sol_PFD,
                              PFD_power_build):
        &#34;&#34;&#34;Calculate fatality rate in the volume for ODH protection failure.

        Calculate failure rate of leak occuring and no safety response
        occuring due to power failure and isolation solenoid failure,
        or power on and ODH system failure.
        O2 concentration is limited only by amount of inert gas the source has.
        Fans are not operational.
        Adds calculation results to the failure_modes list.

        Parameters
        ----------
        source : Source
        failure_mode_name : str
            Name of the failure mode
        leak : tuple (ureg.Quantity {time: -1},
                      ureg.Quantity {length: 3, time: -1},
                      ureg.Quantity {time: 1})
            Leak failure rate, volumetric flow rate, and time of the event.
        sol_PFD : float
            Probability of source solenoid failure.
        PFD_power_building : float
            Probability of power failure.
        &#34;&#34;&#34;
        (leak_failure_rate, q_leak, tau) = leak
        P_no_response = float(PFD_power_build)*float(sol_PFD) +\
            (1-PFD_power_build)*self.PFD_ODH
        P_i = leak_failure_rate * P_no_response
        Q_fan = 0 * ureg(&#39;ft^3/min&#39;)
        O2_conc = conc_vent(self.volume, q_leak, Q_fan, tau)
        F_i = self._fatality_prob(O2_conc)
        phi_i = P_i*F_i
        self.phi += phi_i
        self.failure_modes.append((phi_i, source, failure_mode_name, O2_conc,
                                   leak_failure_rate, P_i, F_i,
                                   PFD_power_build == 1, q_leak, tau, Q_fan))

    def _fatality_fan_powered(self, source, failure_mode_name, leak,
                              PFD_power_build):
        &#34;&#34;&#34;Calculate fatality rates for fan failure on demand.

        Calculate fatality rates for the case of ODH system responding and
        fans powered but some of the fans failing on demand.
        See wiki for further explanation.
        Adds calculation results to the failure_modes list.

        Parameters
        ----------
        source : Source
        failure_mode_name : str
            Name of the failure mode
        leak : tuple (ureg.Quantity {time: -1},
                      ureg.Quantity {length: 3, time: -1},
                      ureg.Quantity {time: 1})
            Leak failure rate, volumetric flow rate, and time of the event.
        sol_PFD : float
            Probability of source solenoid failure.
        PFD_power_building : float
            Probability of power failure.
        &#34;&#34;&#34;
        (leak_failure_rate, q_leak, tau) = leak
        for (P_fan, Q_fan) in self.Fan_flowrates:
            # Probability of power on, ODH system working, and m number of fans
            # with flow rate Q_fan on.
            P_response = (1-PFD_power_build) * (1-self.PFD_ODH) * P_fan
            P_i = leak_failure_rate * P_response
            O2_conc = conc_vent(self.volume, q_leak, Q_fan, tau)
            F_i = self._fatality_prob(O2_conc)
            phi_i = P_i*F_i
            self.phi += phi_i
            self.failure_modes.append((phi_i, source, failure_mode_name,
                                       O2_conc, leak_failure_rate, P_i, F_i,
                                       PFD_power_build == 1, q_leak, tau,
                                       Q_fan))

    def _fan_fail(self, Test_period, Q_fan, N_fans):
        &#34;&#34;&#34;Calculate (Probability, flow) pairs for all combinations of fans
        working.

        All fans are expected to have same volume flow.

        Parameters
        ----------
        Test_period : ureg.Quantity {time: 1}
            Test period of the fans.
        Q_fan : ureg.Quantity {length: 3, time: -1}
            Volumetric flow of a single ODH fan installed in the volume.
        N_fans : int
            Number of fans installed.
        &#34;&#34;&#34;
        # TODO add fans with different volumetric rates (see report as well)
        Fail_rate = self.lambda_fan
        Fan_flowrates = []
        for m in range(N_fans+1):
            # Probability of exactly m units starting
            P_m_fan_work = prob_m_of_n(m, N_fans, Test_period, Fail_rate)
            Fan_flowrates.append((P_m_fan_work, Q_fan*m))
        self.Fan_flowrates = Fan_flowrates

    def _fatality_prob(self, O2_conc):
        &#34;&#34;&#34;Calculate fatality probability for given oxygen concentration.

        The equation is fitted from the FESHM 4240 plot.

        Parameters
        ----------
        O2_conc : float
            Oxygen concentration.

        Returns
        -------
        float
            Fatality rate.
        &#34;&#34;&#34;
        if O2_conc &gt;= 0.18:  # Lowest oxygen concentration above 18%
            Fi = 0
        elif O2_conc &lt;= 0.088:  # 8.8% of oxygen is assumed to be 100% fatal
            Fi = 1
        else:
            # Fi formula, reverse engineered using 8.8% and 18% thresholds
            Fi = 10**(6.5-76*O2_conc)
        return Fi

    def odh_class(self):
        &#34;&#34;&#34;Calculate ODH class as defined in FESHM 4240.

        Returns
        -------
        int
            ODH class.
        &#34;&#34;&#34;
        if self.phi &lt; 1e-7/ureg.hr:
            return 0
        elif self.phi &lt; 1e-5/ureg.hr:
            return 1
        elif self.phi &lt; 1e-3/ureg.hr:
            return 2
        else:
            print(&#39;ODH fatality rate is too high. Please, check calculations&#39;)
            return None

    def report(self, brief=True):
        &#34;&#34;&#34;Print a report for failure modes and effects.

        The report is sorted by fatality rate descending.&#34;&#34;&#34;
        title = f&#39;ODH report for {self}&#39;
        padding = len(title) + 10
        print(&#39;#&#39;*padding)
        print(title)
        print(&#39;-&#39;*padding)
        if brief:
            print(&#39;Printing brief ODH report&#39;)
            print(f&#39;Only leaks with Fatality rate &gt; {SHOW_SENS} are shown&#39;)
        for failure_mode in self.failure_modes:
            phi_i = failure_mode[0]
            source = failure_mode[1]
            failure_mode_name = failure_mode[2]
            O2_conc = failure_mode[3]
            leak_failure_rate = failure_mode[4]
            P_i = failure_mode[5]
            F_i = failure_mode[6]
            power_outage = failure_mode[7]
            q_leak = failure_mode[8]
            tau = failure_mode[9]
            N_fan = int(failure_mode[10] / self.Q_fan)
            Q_fan = failure_mode[10]
            if phi_i &gt;= SHOW_SENS or not brief:
                print()
                print(f&#39; Source:               {source.name}&#39;)
                print(f&#39; Failure:              {failure_mode_name}&#39;)
                print(f&#39; Fatality rate:        {phi_i.to(1/ureg.hr):.2~}&#39;)
                print(f&#39; Building is powered:  {not power_outage}&#39;)
                print(f&#39; Oxygen concentration: {O2_conc:.0%}, &#39;
                      f&#39;{O2_conc/0.21:.0%} percent of norm&#39;)
                print(f&#39; Leak failure rate:    {leak_failure_rate:.3g~}&#39;)
                print(&#39; ODH protection PFD:    &#39;
                      f&#39;{(P_i/leak_failure_rate).to(ureg.dimensionless):.2~}&#39;)
                print(f&#39; Total failure rate:   {P_i.to(1/ureg.hr):.2~}&#39;)
                print(f&#39; Leak rate:            {q_leak:.2~}&#39;)
                print(f&#39; Event duration:       {tau:.2~}&#39;)
                print(f&#39; Fans working:         {N_fan:}&#39;)
                print(f&#39; Fan rate:             {Q_fan:.2~}&#39;)
                print(f&#39; Fatality prob:        {F_i:.2g}&#39;)

    def __str__(self):
        return (f&#39;Volume: {self.name}, {self.volume.to(ureg.ft**3):.2~}&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ODH_analysis.ODH_class.Volume.odh"><code class="name flex">
<span>def <span class="ident">odh</span></span>(<span>self, sources, power_outage=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate ODH fatality rate for given <code><a title="ODH_analysis.ODH_class.Source" href="#ODH_analysis.ODH_class.Source">Source</a></code>s.</p>
<p>For each leak of each source ODH conditions are analyzed and
fatality rates are calculated. The results are collected in
failure_modes list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sources</code></strong> :&ensp;<code>list</code></dt>
<dd>Sources affecting the volume.</dd>
<dt><strong><code>power_outage</code></strong> :&ensp;<code>bool</code></dt>
<dd>Shows whether there is a power outage is in effect.
Default is no outage.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def odh(self, sources, power_outage=False):
    &#34;&#34;&#34;Calculate ODH fatality rate for given `Source`s.

    For each leak of each source ODH conditions are analyzed and
    fatality rates are calculated. The results are collected in
    failure_modes list.

    Parameters
    ----------
    sources : list
        Sources affecting the volume.
    power_outage : bool
        Shows whether there is a power outage is in effect.
        Default is no outage.
    &#34;&#34;&#34;
    self.phi = 0  # Recalculate fatality rate
    self.failure_modes = []
    # Probability of power failure in the building:
    # PFD_power if no outage, 1 if there is outage
    PFD_power_build = (power_outage or
                       TABLE_1[&#39;Electrical Power Failure&#39;][&#39;Demand rate&#39;])
    # Calculate fan probability of failure
    self._fan_fail(self.Test_period, self.Q_fan, self.N_fans)
    # Calculate fatality rates for each source
    for source in sources:
        for failure_mode_name, leak in source.leaks.items():
            leak_failure_rate = leak[0]
            if leak_failure_rate is not None:  # None for constant leak
                self._fatality_no_response(source, failure_mode_name, leak,
                                           source.sol_PFD, PFD_power_build)
                self._fatality_fan_powered(source, failure_mode_name, leak,
                                           PFD_power_build)
            else:
                # TODO rework constant leak (will throw errors)
                raise NotImplementedError(&#39;Constant leak analysis is not &#39;
                                          &#39;implemented yet.&#39;)
                &#34;&#34;&#34;O2_conc = conc_vent(self.volume, q_leak, 0*ureg(&#39;ft^3/min&#39;), tau)
                F_i = self._fatality_prob(O2_conc)
                if F_i &gt; 0:
                    print(&#39;Constant leak can be fatal: {source}, \
                    Leak: {leak_rate:.3g~}, tau: {tau:.3g~}&#39;)
                phi_i = F_i / tau  #  Assessing fatality rate of the cont. leak
                self.failure_modes.append((phi_i, source, failure_mode_name, O2_conc,
                                           1.0, 1.0,
                                           F_i, power_outage, q_leak, tau, Q_fan))
                &#34;&#34;&#34;
    # Sort failure modes by fatality rate
    self.failure_modes.sort(key=lambda x: x[0], reverse=True)</code></pre>
</details>
</dd>
<dt id="ODH_analysis.ODH_class.Volume.odh_class"><code class="name flex">
<span>def <span class="ident">odh_class</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate ODH class as defined in FESHM 4240.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>ODH class.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def odh_class(self):
    &#34;&#34;&#34;Calculate ODH class as defined in FESHM 4240.

    Returns
    -------
    int
        ODH class.
    &#34;&#34;&#34;
    if self.phi &lt; 1e-7/ureg.hr:
        return 0
    elif self.phi &lt; 1e-5/ureg.hr:
        return 1
    elif self.phi &lt; 1e-3/ureg.hr:
        return 2
    else:
        print(&#39;ODH fatality rate is too high. Please, check calculations&#39;)
        return None</code></pre>
</details>
</dd>
<dt id="ODH_analysis.ODH_class.Volume.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self, brief=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a report for failure modes and effects.</p>
<p>The report is sorted by fatality rate descending.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(self, brief=True):
    &#34;&#34;&#34;Print a report for failure modes and effects.

    The report is sorted by fatality rate descending.&#34;&#34;&#34;
    title = f&#39;ODH report for {self}&#39;
    padding = len(title) + 10
    print(&#39;#&#39;*padding)
    print(title)
    print(&#39;-&#39;*padding)
    if brief:
        print(&#39;Printing brief ODH report&#39;)
        print(f&#39;Only leaks with Fatality rate &gt; {SHOW_SENS} are shown&#39;)
    for failure_mode in self.failure_modes:
        phi_i = failure_mode[0]
        source = failure_mode[1]
        failure_mode_name = failure_mode[2]
        O2_conc = failure_mode[3]
        leak_failure_rate = failure_mode[4]
        P_i = failure_mode[5]
        F_i = failure_mode[6]
        power_outage = failure_mode[7]
        q_leak = failure_mode[8]
        tau = failure_mode[9]
        N_fan = int(failure_mode[10] / self.Q_fan)
        Q_fan = failure_mode[10]
        if phi_i &gt;= SHOW_SENS or not brief:
            print()
            print(f&#39; Source:               {source.name}&#39;)
            print(f&#39; Failure:              {failure_mode_name}&#39;)
            print(f&#39; Fatality rate:        {phi_i.to(1/ureg.hr):.2~}&#39;)
            print(f&#39; Building is powered:  {not power_outage}&#39;)
            print(f&#39; Oxygen concentration: {O2_conc:.0%}, &#39;
                  f&#39;{O2_conc/0.21:.0%} percent of norm&#39;)
            print(f&#39; Leak failure rate:    {leak_failure_rate:.3g~}&#39;)
            print(&#39; ODH protection PFD:    &#39;
                  f&#39;{(P_i/leak_failure_rate).to(ureg.dimensionless):.2~}&#39;)
            print(f&#39; Total failure rate:   {P_i.to(1/ureg.hr):.2~}&#39;)
            print(f&#39; Leak rate:            {q_leak:.2~}&#39;)
            print(f&#39; Event duration:       {tau:.2~}&#39;)
            print(f&#39; Fans working:         {N_fan:}&#39;)
            print(f&#39; Fan rate:             {Q_fan:.2~}&#39;)
            print(f&#39; Fatality prob:        {F_i:.2g}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ODH_analysis" href="index.html">ODH_analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ODH_analysis.ODH_class.conc_after" href="#ODH_analysis.ODH_class.conc_after">conc_after</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.conc_final" href="#ODH_analysis.ODH_class.conc_final">conc_final</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.conc_vent" href="#ODH_analysis.ODH_class.conc_vent">conc_vent</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.print_result" href="#ODH_analysis.ODH_class.print_result">print_result</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.prob_m_of_n" href="#ODH_analysis.ODH_class.prob_m_of_n">prob_m_of_n</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ODH_analysis.ODH_class.Source" href="#ODH_analysis.ODH_class.Source">Source</a></code></h4>
<ul class="">
<li><code><a title="ODH_analysis.ODH_class.Source.combine" href="#ODH_analysis.ODH_class.Source.combine">combine</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.Source.dewar_insulation_failure" href="#ODH_analysis.ODH_class.Source.dewar_insulation_failure">dewar_insulation_failure</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.Source.failure_mode" href="#ODH_analysis.ODH_class.Source.failure_mode">failure_mode</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.Source.gas_pipe_failure" href="#ODH_analysis.ODH_class.Source.gas_pipe_failure">gas_pipe_failure</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.Source.print_leaks" href="#ODH_analysis.ODH_class.Source.print_leaks">print_leaks</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.Source.sol_PFD" href="#ODH_analysis.ODH_class.Source.sol_PFD">sol_PFD</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.Source.transfer_line_failure" href="#ODH_analysis.ODH_class.Source.transfer_line_failure">transfer_line_failure</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ODH_analysis.ODH_class.Volume" href="#ODH_analysis.ODH_class.Volume">Volume</a></code></h4>
<ul class="">
<li><code><a title="ODH_analysis.ODH_class.Volume.odh" href="#ODH_analysis.ODH_class.Volume.odh">odh</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.Volume.odh_class" href="#ODH_analysis.ODH_class.Volume.odh_class">odh_class</a></code></li>
<li><code><a title="ODH_analysis.ODH_class.Volume.report" href="#ODH_analysis.ODH_class.Volume.report">report</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>